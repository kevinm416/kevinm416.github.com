---
layout: post
title: Tetris as an Exercise in Multithreaded Programming
---

h1. {{ page.title }}

In previous posts we defined the "representation":../../01/11/tetromino-representation.html that we would use for Tetrominos, and how we would be able to generate repeating "events":../../01/24/tetris-timing-thread.html using a thread that runs outside of the GUI's main loop. Now we need to tie both of those together within a GUI framework.

First we will look at how the GUI is laid out. Next we will discuss the data structures used to keep track of the game state. Then we will talk about what events we need to react to, and implement handlers for each such event.

A teaser of the finished product, as well as the "code":https://github.com/kevinm416/kevinm416.github.com/blob/master/code/tetris/tetris.py:

!/resources/tetris-screenshot.png(final)!

h3. GUI Overview

We are going to use wxPython as the GUI framework. A @wx.Frame@ is what we normally think of as a program window, so our Tetris game is going to be a subclass of a @wx.Frame@. Inside the @wx.Frame@ we are going to need more widgets for the visual items that we see. 

!/resources/tetris-layout.png(layout)! 

The @wx.BoxSizer@ directly inside the @wx.Frame@ holds a @wx.Panel@ on which we will draw the Tetris game, and another @wx.BoxSizer@ which holds information about the current game. The actual code for creating and nesting these elements is relatively long and uninteresting, so it will not be included here. 

h3. Game State

First we define some constants associated with a Tetris game.

{% highlight python %}
class Tetris(wx.Frame):
    BLOCK_SIZE = 20
    COLUMNS = 10
    ROWS = 20
    FALL_INTERVAL = 1.0
    FALL_SPEEDUP = 0.8
    BOARD_SIZE = (BLOCK_SIZE * COLUMNS, BLOCK_SIZE * ROWS)
    SCORE_MULTIPLIER = (40, 100, 300, 1200)
{% endhighlight %}

And set initial values of a @Tetris@ instance. The meanings of these variables can be deduced from their names.

{% highlight python %}
    def __init__(self, parent, title):
        wx.Frame.__init__(self, parent, title=title)
        self.move_lock = threading.Lock() # must hold to move falling_block
        self.fall_interval = Tetris.FALL_INTERVAL
        self.block_src = Block.rand()
        self.falling_block = self.block_src.next()
        self.next_block = self.block_src.next()
        self.paused = False
        self.game_over = False
        self.fall_hard_available = True
        self.score = self.level = self.lines = 0
        self.bitmap = wx.EmptyBitmap(*Tetris.BOARD_SIZE)
{% endhighlight %}

Now, we are going to need some data structures to keep track of which squares on the board are occupied, and by which color piece. Since the board is rectangular, it lends itself to being represented by a 2D list. Initially, all entries in the list will be a value that evaluates to @False@, but as blocks are locked into place, the value at the appropriate list position will be changed to the color of the block.

If we think about how we are using this data structure, we notice that we are going to need to remove elements that represent rows frequently. To accommodate this access pattern, we will make entries in the top level list other lists that represent rows from the board. Using Python's slice operations, we will then be able to remove rows from the data structure easily.

{% highlight python %}
        self.used_positions = [[None]*Tetris.COLUMNS for i in xrange(Tetris.ROWS)]
{% endhighlight %}

Each row starts with @Tetris.COLUMNS@ open slots, and as blocks settle, they use up open slots. If we count down the number of open slots in a row, we will not have to iterate over a row in @self.used_positions@ to determine if it is empty. For this reason we introduce @self.open_count@, where the value at position @i@ corresponds to the number of remaining positions in row @i@.

{% highlight python %}
        self.open_count = [Tetris.COLUMNS] * Tetris.ROWS
{% endhighlight %}

h3. Handling Events

There are three different events generated by the wxPython thread that we are concerned with: @wx.EVT_CLOSE@, @wx.EVT_PAINT@, and @wx.EVT_CHAR@. We will use the @Timer@ class to generate our own events that trigger the active block to fall. We will bind each of these events to their own handler function.
	
{% highlight python %}
        # still inside __init__
        self.Bind(wx.EVT_CLOSE, self.OnClose)
        self.Bind(wx.EVT_PAINT, self.Paint)
        self.panel.Bind(wx.EVT_CHAR, self.OnKeyDown)
        self.timer = Timer(self.fall_interval, self.Fall)
        self.timer.start()
        self.Paint()
{% endhighlight %}

You may have noticed that @wx.EVT_CHAR@ is bound to @self.panel@ instead of @self@. This is because @wx.Frame@ does not catch @wx.EVT_CHAR@ events in some Linux distributions (as I "discovered":http://stackoverflow.com/questions/8707160/wxpython-capture-keyboard-events-in-a-wx-frame).  

h3. Close Events

When we get an event of type @wx.EVT_CLOSE@ we need to signal to the timing thread that it's time to stop, and then wait for it to finish. Remember that our @Timer@ implementation allows us to pause it, so we neet to unpause it before exiting. After joining we can safely close the game. If we did not join with the timer thread, it could try to call @Tetris.Fall@ after the @Tetris@ instance had been destroyed.

{% highlight python %}
    def OnClose(self, e):
        self.timer.cancel()
        self.timer.restart()
        self.timer.join()
        e.Skip()
{% endhighlight %}

h3. Paint Events

Receiving @wx.EVT_PAINT@ means that some area needs to be redrawn. For example, this event is often called by the OS when an area becomes visible after being hidden behind another window. As a result, we will redraw the board.

To increase efficiency in this method, we first draw onto @self.bitmap@, which is a buffer that is not visible. Then we write the contents of @self.bitmap@ over the contents of the @self.panel@'s device context.

{% highlight python %}
    def Paint(self):
        dc = wx.MemoryDC()
        dc.SelectObject(self.bitmap)
        dc.Clear()
        dc.BeginDrawing()
        dc.SetBrush(wx.Brush(wx.Color(*self.falling_block.color), wx.SOLID))
        for (i, j) in self.falling_block.absolute_positions():
            dc.DrawRectangle(j * Tetris.BLOCK_SIZE,
                             i * Tetris.BLOCK_SIZE,
                             Tetris.BLOCK_SIZE,
                             Tetris.BLOCK_SIZE)

        for i in xrange(len(self.used_positions)):
            for j in xrange(len(self.used_positions[i])):
                if self.used_positions[i][j]:
                    dc.SetBrush(wx.Brush(wx.Color(
                        *self.used_positions[i][j]), wx.SOLID))
                    dc.DrawRectangle(j * Tetris.BLOCK_SIZE,
                                     i * Tetris.BLOCK_SIZE,
                                     Tetris.BLOCK_SIZE,
                                     Tetris.BLOCK_SIZE)
        dc.EndDrawing()
        dest_dc = wx.PaintDC(self.panel)
        dest_dc.Blit(0, 0, Tetris.BOARD_SIZE[0], Tetris.BOARD_SIZE[1],
                     dc, 0, 0)
{% endhighlight %}

h3. Keyboard Events

Each time the player presses a key on the keyboard, we need to check if that key matches one of the keys that controls the game. Most of the time, that control will influence the placement of the falling block. The @Tetris.OnKeydown@ method was designed in parallel with the @Block.(move_*|rotate_*)@ methods to provide a clean way of trying moves. The idea is, @Block@'s are immutable, and will return a new @Block@ when asked to move. We will attempt to place that new block in the board, and if we cannot, then we will discard the new @Block@.

{% highlight python %}
def OnKeyDown(self, event=None):
        key_code = event.GetKeyCode()
        new_block = None
        rotation = False
        if key_code == wx.WXK_LEFT:
            new_block = self.falling_block.move_left()
        elif key_code == wx.WXK_DOWN:
            new_block = self.falling_block.rotate_left()
            rotation = True
        elif key_code == wx.WXK_RETURN:
            if self.fall_hard_available:
                self.move_lock.acquire()
                new_block = self.falling_block.fall()
                while self.AttemptMove(new_block, False):
                    new_block = new_block.fall()
                self.move_lock.release()
                self.timer.restart()
                self.fall_hard_available = False
        elif key_code == wx.WXK_ESCAPE:
            wx.CallAfter(self.OnExit)
        # etc, etc, etc
{% endhighlight %}

An important note here is that @Tetris.AttemptMove@ can change game state that is also accessible by the timer thread. As a result, we need to synchronize access to the method.

{% highlight python %}
        if new_block:
            self.move_lock.acquire()
            self.AttemptMove(new_block, rotation)
            self.move_lock.release()
{% endhighlight %}

@Timer.AttemptMove@ is a method that takes a block, and a Boolean that signifies whether the attempted move is a rotation. If the move is a translation, the first check to see if it fits on the board is sufficient to reject the move. 

{% highlight python %}
    def AttemptMove(self, new_block, rotation):
        success = True
        for (row, col) in new_block.absolute_positions():
            if row >= Tetris.ROWS or col >= Tetris.COLUMNS or col < 0 \
                    or (row >= 0 and self.used_positions[row][col]):
                success = False
                break
{% endhighlight %}

If the move is a rotation and does not fit, we also check whether translating the piece one square either to the left or right would be valid. This allows players to rotate blocks when they are up against the wall.

{% highlight python %}
        if rotation and (not success):
            lblock = new_block.move_left()
            if self.AttemptMove(lblock, False):
                new_block = lblock
                success = True 
            else:
                rblock = new_block.move_right()
                if self.AttemptMove(rblock, False):
                    new_block = rblock
                    success = True
        if success:
            self.falling_block = new_block
            wx.CallAfter(self.Paint)
        return success
{% endhighlight %}



h3. Fall Events

Whenever the timing thread signals an event, we need to move @self.falling_block@ down by one unit if possible. Otherwise remove completed lines, and adjust the score, level, and line count. Like @Tetris.AttemptMove@, @Tetris.Fall@ modifies game state that is accessible by more than one thread, so we will acquire @self.move_lock@ before changing anything in the @Tetris@ instance.

{% highlight python %}
    def Fall(self):
        self.move_lock.acquire()
        fall_block = self.falling_block.fall()
{% endhighlight %}

Above, if @fall_block@ is a valid move, then @Tetris.Fall@ is pretty much done. The difficult case is when @fall_block@ is not valid, and we need to remove completed lines, and update game state.

We look at each position that @self.falling_block@ is occupying, and decrement the number of available positions in that row. At the same time we indicate that the position is no longer available by setting @self.used_positions@ to it's color, which is "truthy".

{% highlight python %}
        if not self.AttemptMove(fall_block, False):
            rows_cleared = 0
            positions = list(self.falling_block.absolute_positions())
            for (i, j) in positions:
                self.open_count[i] -= 1
                self.used_positions[i][j] = fall_block.color
{% endhighlight %}

Now we need to check for any rows that do not have available positions, and remove them from the board. If we sort the positions by descending row index, we can remove each full row, shift the rest down, and add an empty row at the top of @self.used_positions@. Remember to do the same to @self.open_count@, so that the rows match up with the count of available positions.

{% highlight python %}
            positions.sort(key=lambda p: p[0], reverse=False) 
            for (i, j) in positions:
                if self.open_count[i] == 0:
                    self.used_positions = [[None]*Tetris.COLUMNS] + \
                        self.used_positions[0:i] + self.used_positions[i+1:]
                    self.open_count = [Tetris.COLUMNS] + \
                        self.open_count[0:i] + self.open_count[i+1:]
                    rows_cleared += 1
{% endhighlight %}

If any rows were removed, we will need to update the score, line count, level, and fall interval accordingly. Note the use of @wx.CallAfter@ because we are modifying wxPython widgets from the timer thread.

{% highlight python %}
            if rows_cleared > 0:
                self.lines += rows_cleared
                wx.CallAfter(self.lines_text.SetLabel, "Lines: %s" % self.lines)
                self.score += Tetris.SCORE_MULTIPLIER[rows_cleared - 1] * \
                    (self.level + 1)
                wx.CallAfter(self.score_text.SetLabel, "Score: %s" % self.score)
                new_level = self.lines/5 + 1
                if not new_level == self.level:
                    self.level = new_level
                    wx.CallAfter(self.level_text.SetLabel, \
                        "Level: %s" % self.level)
                    self.fall_interval *= Tetris.FALL_SPEEDUP
                    self.timer.reschedule(self.fall_interval)
            self.falling_block = self.next_block
            self.next_block = self.block_src.next()
            wx.CallAfter(self.PaintNextBlock)
{% endhighlight %}

If the block that we just assigned to @self.next_block@ is not in a valid position then the game is over. 

{% highlight python %}
            if not self.AttemptMove(self.falling_block, False):
                self.game_over = True
                self.timer.pause()
{% endhighlight %}

h3. Conclusion

Because the code was somewhat long, it did not seem worthwhile to go through absolutely everything. As a result, some pieces are not completely tied up. For example, @self.timer@ is never unpaused after a game over. To see a complete implementation, with some extra features not covered here, look "here":https://github.com/kevinm416/kevinm416.github.com/blob/master/code/tetris/tetris.py.